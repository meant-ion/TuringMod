import { __assign, __awaiter, __generator } from "tslib";
import { createLogger } from '@d-fischer/logger';
var PartitionedTimeBasedRateLimiter = /** @class */ (function () {
    function PartitionedTimeBasedRateLimiter(_a) {
        var logger = _a.logger, bucketSize = _a.bucketSize, timeFrame = _a.timeFrame, doRequest = _a.doRequest, getPartitionKey = _a.getPartitionKey;
        this._partitionedQueue = new Map();
        this._usedFromBucket = new Map();
        this._logger = createLogger(__assign({ name: 'rate-limiter', emoji: true }, logger));
        this._bucketSize = bucketSize;
        this._timeFrame = timeFrame;
        this._callback = doRequest;
        this._partitionKeyCallback = getPartitionKey;
    }
    PartitionedTimeBasedRateLimiter.prototype.request = function (req) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var _a;
                        var reqSpec = {
                            req: req,
                            resolve: resolve,
                            reject: reject
                        };
                        var partitionKey = _this._partitionKeyCallback(req);
                        var usedFromBucket = (_a = _this._usedFromBucket.get(partitionKey)) !== null && _a !== void 0 ? _a : 0;
                        if (usedFromBucket >= _this._bucketSize) {
                            var queue = _this._getPartitionedQueue(partitionKey);
                            queue.push(reqSpec);
                            _this._logger.warn("Rate limit of " + _this._bucketSize + " for partition " + partitionKey + " was reached, waiting for a free bucket entry; queue size is " + queue.length);
                        }
                        else {
                            void _this._runRequest(reqSpec, partitionKey);
                        }
                    })];
            });
        });
    };
    PartitionedTimeBasedRateLimiter.prototype._getPartitionedQueue = function (partitionKey) {
        if (this._partitionedQueue.has(partitionKey)) {
            return this._partitionedQueue.get(partitionKey);
        }
        var newQueue = [];
        this._partitionedQueue.set(partitionKey, newQueue);
        return newQueue;
    };
    PartitionedTimeBasedRateLimiter.prototype._runRequest = function (reqSpec, partitionKey) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var queue, req, resolve, reject, _b, e_1;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        queue = this._getPartitionedQueue(partitionKey);
                        this._logger.debug("doing a request for partiton " + partitionKey + ", new queue length is " + queue.length);
                        this._usedFromBucket.set(partitionKey, ((_a = this._usedFromBucket.get(partitionKey)) !== null && _a !== void 0 ? _a : 0) + 1);
                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        _b = resolve;
                        return [4 /*yield*/, this._callback(req)];
                    case 2:
                        _b.apply(void 0, [_c.sent()]);
                        return [3 /*break*/, 5];
                    case 3:
                        e_1 = _c.sent();
                        reject(e_1);
                        return [3 /*break*/, 5];
                    case 4:
                        setTimeout(function () {
                            var newUsed = _this._usedFromBucket.get(partitionKey) - 1;
                            _this._usedFromBucket.set(partitionKey, newUsed);
                            if (queue.length && newUsed < _this._bucketSize) {
                                _this._runNextRequest(partitionKey);
                            }
                        }, this._timeFrame);
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    PartitionedTimeBasedRateLimiter.prototype._runNextRequest = function (partitionKey) {
        var queue = this._getPartitionedQueue(partitionKey);
        var reqSpec = queue.shift();
        if (reqSpec) {
            void this._runRequest(reqSpec, partitionKey);
        }
    };
    return PartitionedTimeBasedRateLimiter;
}());
export { PartitionedTimeBasedRateLimiter };
//# sourceMappingURL=PartitionedTimeBasedRateLimiter.mjs.map
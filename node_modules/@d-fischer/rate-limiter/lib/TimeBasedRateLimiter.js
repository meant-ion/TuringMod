"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeBasedRateLimiter = void 0;
var tslib_1 = require("tslib");
var logger_1 = require("@d-fischer/logger");
var TimeBasedRateLimiter = /** @class */ (function () {
    function TimeBasedRateLimiter(_a) {
        var logger = _a.logger, bucketSize = _a.bucketSize, timeFrame = _a.timeFrame, doRequest = _a.doRequest;
        this._queue = [];
        this._usedFromBucket = 0;
        this._logger = logger_1.createLogger(tslib_1.__assign({ name: 'rate-limiter', emoji: true }, logger));
        this._bucketSize = bucketSize;
        this._timeFrame = timeFrame;
        this._callback = doRequest;
    }
    TimeBasedRateLimiter.prototype.request = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var reqSpec = {
                            req: req,
                            resolve: resolve,
                            reject: reject
                        };
                        if (_this._usedFromBucket >= _this._bucketSize) {
                            _this._queue.push(reqSpec);
                            _this._logger.warn("Rate limit of " + _this._bucketSize + " was reached, waiting for a free bucket entry; queue size is " + _this._queue.length);
                        }
                        else {
                            void _this._runRequest(reqSpec);
                        }
                    })];
            });
        });
    };
    TimeBasedRateLimiter.prototype._runRequest = function (reqSpec) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, resolve, reject, _a, e_1;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this._logger.debug("doing a request, new queue length is " + this._queue.length);
                        this._usedFromBucket += 1;
                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        _a = resolve;
                        return [4 /*yield*/, this._callback(req)];
                    case 2:
                        _a.apply(void 0, [_b.sent()]);
                        return [3 /*break*/, 5];
                    case 3:
                        e_1 = _b.sent();
                        reject(e_1);
                        return [3 /*break*/, 5];
                    case 4:
                        setTimeout(function () {
                            _this._usedFromBucket -= 1;
                            if (_this._queue.length && _this._usedFromBucket < _this._bucketSize) {
                                _this._runNextRequest();
                            }
                        }, this._timeFrame);
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    TimeBasedRateLimiter.prototype._runNextRequest = function () {
        var reqSpec = this._queue.shift();
        if (reqSpec) {
            void this._runRequest(reqSpec);
        }
    };
    return TimeBasedRateLimiter;
}());
exports.TimeBasedRateLimiter = TimeBasedRateLimiter;
//# sourceMappingURL=TimeBasedRateLimiter.js.map
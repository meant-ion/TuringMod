import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { DataObject, rawDataSymbol, rtfm } from '@twurple/common';
import { NoSubscriptionProgramError } from "../../../errors/NoSubscriptionProgramError.mjs";
/**
 * A Twitch user.
 */
let HelixUser = class HelixUser extends DataObject {
    /** @private */
    constructor(data, client) {
        super(data);
        this._client = client;
    }
    /** @private */
    get cacheKey() {
        return this[rawDataSymbol].id;
    }
    /**
     * The ID of the user.
     */
    get id() {
        return this[rawDataSymbol].id;
    }
    /**
     * The name of the user.
     */
    get name() {
        return this[rawDataSymbol].login;
    }
    /**
     * The display name of the user.
     */
    get displayName() {
        return this[rawDataSymbol].display_name;
    }
    /**
     * The description of the user.
     */
    get description() {
        return this[rawDataSymbol].description;
    }
    /**
     * The type of the user.
     */
    get type() {
        return this[rawDataSymbol].type;
    }
    /**
     * The type of the user.
     */
    get broadcasterType() {
        return this[rawDataSymbol].broadcaster_type;
    }
    /**
     * The URL of the profile picture of the user.
     */
    get profilePictureUrl() {
        return this[rawDataSymbol].profile_image_url;
    }
    /**
     * The URL of the offline video placeholder of the user.
     */
    get offlinePlaceholderUrl() {
        return this[rawDataSymbol].offline_image_url;
    }
    /**
     * The total number of views of the user's channel.
     */
    get views() {
        return this[rawDataSymbol].view_count;
    }
    /**
     * The date when the user was created, i.e. when they registered on Twitch.
     */
    get creationDate() {
        return new Date(this[rawDataSymbol].created_at);
    }
    /**
     * Retrieves the channel's stream data.
     */
    async getStream() {
        return await this._client.streams.getStreamByUserId(this);
    }
    /**
     * Retrieves a list of broadcasters the user follows.
     */
    async getFollows() {
        return await this._client.users.getFollows({ user: this });
    }
    /**
     * Retrieves the follow data of the given user to the broadcaster.
     *
     * @param user The user to check the follow from.
     */
    async getFollowFrom(user) {
        return await this._client.users.getFollowFromUserToBroadcaster(user, this);
    }
    /**
     * Retrieves the follow data of the user to the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the follow to.
     */
    async getFollowTo(broadcaster) {
        return await this._client.users.getFollowFromUserToBroadcaster(this, broadcaster);
    }
    /**
     * Checks whether the user is following the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the user's follow to.
     */
    async follows(broadcaster) {
        return await this._client.users.userFollowsBroadcaster(this, broadcaster);
    }
    /**
     * Checks whether the given user is following the broadcaster.
     *
     * @param user The user to check the broadcaster's follow from.
     */
    async isFollowedBy(user) {
        return await this._client.users.userFollowsBroadcaster(user, this);
    }
    /**
     * Retrieves the subscription data for the user to the given broadcaster, or `null` if the user is not subscribed.
     *
     * @param broadcaster The broadcaster you want to get the subscription data for.
     */
    async getSubscriptionTo(broadcaster) {
        return await this._client.subscriptions.getSubscriptionForUser(broadcaster, this);
    }
    /**
     * Checks whether the user is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster you want to check the subscription for.
     */
    async isSubscribedTo(broadcaster) {
        try {
            return (await this.getSubscriptionTo(broadcaster)) !== null;
        }
        catch (e) {
            if (e instanceof NoSubscriptionProgramError) {
                return false;
            }
            throw e;
        }
    }
};
__decorate([
    Enumerable(false)
], HelixUser.prototype, "_client", void 0);
HelixUser = __decorate([
    rtfm('api', 'HelixUser', 'id')
], HelixUser);
export { HelixUser };

var HelixUserApi_1;
import { __decorate } from "tslib";
import { extractUserId, extractUserName, HellFreezesOverError, rtfm } from '@twurple/common';
import { BaseApi } from "../../BaseApi.mjs";
import { HelixPaginatedRequest } from "../HelixPaginatedRequest.mjs";
import { HelixPaginatedRequestWithTotal } from "../HelixPaginatedRequestWithTotal.mjs";
import { createPaginatedResult, createPaginatedResultWithTotal } from "../HelixPaginatedResult.mjs";
import { makePaginationQuery } from "../HelixPagination.mjs";
import { HelixInstalledExtensionList } from "./Extensions/HelixInstalledExtensionList.mjs";
import { HelixUserExtension } from "./Extensions/HelixUserExtension.mjs";
import { HelixFollow } from "./HelixFollow.mjs";
import { HelixPrivilegedUser } from "./HelixPrivilegedUser.mjs";
import { HelixUser } from "./HelixUser.mjs";
import { HelixUserBlock } from "./HelixUserBlock.mjs";
/**
 * The Helix API methods that deal with users.
 *
 * Can be accessed using `client.users` on an {@ApiClient} instance.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * const user = await api.users.getUserById('125328655');
 * ```
 */
let HelixUserApi = HelixUserApi_1 = class HelixUserApi extends BaseApi {
    /**
     * Retrieves the user data for the given list of user IDs.
     *
     * @param userIds The user IDs you want to look up.
     */
    async getUsersByIds(userIds) {
        return await this._getUsers('id', userIds.map(extractUserId));
    }
    /**
     * Retrieves the user data for the given list of user names.
     *
     * @param userNames The user names you want to look up.
     */
    async getUsersByNames(userNames) {
        return await this._getUsers('login', userNames.map(extractUserName));
    }
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    async getUserById(userId) {
        const users = await this._getUsers('id', [extractUserId(userId)]);
        return users.length ? users[0] : null;
    }
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    async getUserByName(userName) {
        const users = await this._getUsers('login', [extractUserName(userName)]);
        return users.length ? users[0] : null;
    }
    /**
     * Retrieves the user data of the currently authenticated user.
     *
     * @param withEmail Whether you need the user's email address.
     */
    async getMe(withEmail = false) {
        var _a;
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users',
            scope: withEmail ? 'user:read:email' : ''
        });
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!((_a = result.data) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new HellFreezesOverError('Could not get authenticated user');
        }
        return new HelixPrivilegedUser(result.data[0], this._client);
    }
    /**
     * Updates the currently authenticated user's data.
     *
     * @param data The data to update.
     */
    async updateUser(data) {
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users',
            method: 'PUT',
            scope: 'user:edit',
            query: {
                description: data.description
            }
        });
        return new HelixPrivilegedUser(result.data[0], this._client);
    }
    /**
     * Retrieves a list of follow relations.
     *
     * @param filter
     *
     * @expandParams
     */
    async getFollows(filter) {
        const result = await this._client.callApi({
            url: 'users/follows',
            type: 'helix',
            query: {
                ...HelixUserApi_1._makeFollowsQuery(filter),
                ...makePaginationQuery(filter)
            }
        });
        return createPaginatedResultWithTotal(result, HelixFollow, this._client);
    }
    /**
     * Creates a paginator for follow relations.
     *
     * @param filter
     *
     * @expandParams
     */
    getFollowsPaginated(filter) {
        const query = HelixUserApi_1._makeFollowsQuery(filter);
        return new HelixPaginatedRequestWithTotal({
            url: 'users/follows',
            query
        }, this._client, data => new HelixFollow(data, this._client));
    }
    /**
     * Retrieves the follow relation bewteen a given user and a given broadcaster.
     *
     * @param user The user to retrieve the follow relation for.
     * @param broadcaster The broadcaster to retrieve the follow relation for.
     */
    async getFollowFromUserToBroadcaster(user, broadcaster) {
        const { data: result } = await this.getFollows({ user, followedUser: broadcaster });
        return result.length ? result[0] : null;
    }
    /**
     * Checks whether the given user follows the given broadcaster.
     *
     * @param user The user to check the follow for.
     * @param broadcaster The broadcaster to check the follow for.
     */
    async userFollowsBroadcaster(user, broadcaster) {
        return (await this.getFollowFromUserToBroadcaster(user, broadcaster)) !== null;
    }
    /**
     * Retrieves a list of users blocked by the given user.
     *
     * @param user The user to retrieve blocks for.
     * @param pagination
     *
     * @expandParams
     */
    async getBlocks(user, pagination) {
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users/blocks',
            scope: 'user:read:blocked_users',
            query: {
                broadcaster_id: extractUserId(user),
                ...makePaginationQuery(pagination)
            }
        });
        return createPaginatedResult(result, HelixUserBlock, this._client);
    }
    /**
     * Creates a paginator for users blocked by the given user.
     *
     * @param user The user to retrieve blocks for.
     */
    getBlocksPaginated(user) {
        return new HelixPaginatedRequest({
            url: 'users/blocks',
            scope: 'user:read:blocked_users',
            query: {
                broadcaster_id: extractUserId(user)
            }
        }, this._client, data => new HelixUserBlock(data, this._client));
    }
    /**
     * Blocks the given user.
     *
     * @param target The user to block.
     * @param additionalInfo Additional info to give context to the block.
     *
     * @expandParams
     */
    async createBlock(target, additionalInfo = {}) {
        await this._client.callApi({
            type: 'helix',
            url: 'users/blocks',
            method: 'PUT',
            scope: 'user:manage:blocked_users',
            query: {
                target_user_id: extractUserId(target),
                source_context: additionalInfo.sourceContext,
                reason: additionalInfo.reason
            }
        });
    }
    /**
     * Unblocks the given user.
     *
     * @param target The user to unblock.
     */
    async deleteBlock(target) {
        await this._client.callApi({
            type: 'helix',
            url: 'users/blocks',
            method: 'DELETE',
            scope: 'user:manage:blocked_users',
            query: {
                target_user_id: extractUserId(target)
            }
        });
    }
    /**
     * Retrieves a list of all extensions for the authenticated user.
     */
    async getMyExtensions() {
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users/extensions/list'
        });
        return result.data.map(data => new HelixUserExtension(data));
    }
    /**
     * Retrieves a list of all installed extensions for the given user.
     *
     * @param user The user to get the installed extensions for.
     *
     * If not given, get the installed extensions for the authenticated user.
     */
    async getActiveExtensions(user) {
        const userId = user ? extractUserId(user) : undefined;
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users/extensions',
            query: {
                user_id: userId
            }
        });
        return new HelixInstalledExtensionList(result.data);
    }
    /**
     * Updates the installed extensions for the authenticated user.
     *
     * @param data The extension installation payload.
     *
     * The format is shown on the [Twitch documentation](https://dev.twitch.tv/docs/api/reference#update-user-extensions).
     * Don't use the "data" wrapper though.
     */
    async updateMyActiveExtensions(data) {
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users/extensions',
            jsonBody: { data }
        });
        return new HelixInstalledExtensionList(result.data);
    }
    static _makeFollowsQuery(filter) {
        const query = {};
        let hasUserIdParam = false;
        if (filter.user) {
            query.from_id = extractUserId(filter.user);
            hasUserIdParam = true;
        }
        if (filter.followedUser) {
            query.to_id = extractUserId(filter.followedUser);
            hasUserIdParam = true;
        }
        if (!hasUserIdParam) {
            throw new TypeError('At least one of user and followedUser have to be set');
        }
        return query;
    }
    async _getUsers(lookupType, param) {
        if (param.length === 0) {
            return [];
        }
        const query = { [lookupType]: param };
        const result = await this._client.callApi({
            type: 'helix',
            url: 'users',
            query
        });
        return result.data.map(userData => new HelixUser(userData, this._client));
    }
};
HelixUserApi = HelixUserApi_1 = __decorate([
    rtfm('api', 'HelixUserApi')
], HelixUserApi);
export { HelixUserApi };

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelixUser = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const common_1 = require("@twurple/common");
const NoSubscriptionProgramError_1 = require("../../../errors/NoSubscriptionProgramError");
/**
 * A Twitch user.
 */
let HelixUser = class HelixUser extends common_1.DataObject {
    /** @private */
    constructor(data, client) {
        super(data);
        this._client = client;
    }
    /** @private */
    get cacheKey() {
        return this[common_1.rawDataSymbol].id;
    }
    /**
     * The ID of the user.
     */
    get id() {
        return this[common_1.rawDataSymbol].id;
    }
    /**
     * The name of the user.
     */
    get name() {
        return this[common_1.rawDataSymbol].login;
    }
    /**
     * The display name of the user.
     */
    get displayName() {
        return this[common_1.rawDataSymbol].display_name;
    }
    /**
     * The description of the user.
     */
    get description() {
        return this[common_1.rawDataSymbol].description;
    }
    /**
     * The type of the user.
     */
    get type() {
        return this[common_1.rawDataSymbol].type;
    }
    /**
     * The type of the user.
     */
    get broadcasterType() {
        return this[common_1.rawDataSymbol].broadcaster_type;
    }
    /**
     * The URL of the profile picture of the user.
     */
    get profilePictureUrl() {
        return this[common_1.rawDataSymbol].profile_image_url;
    }
    /**
     * The URL of the offline video placeholder of the user.
     */
    get offlinePlaceholderUrl() {
        return this[common_1.rawDataSymbol].offline_image_url;
    }
    /**
     * The total number of views of the user's channel.
     */
    get views() {
        return this[common_1.rawDataSymbol].view_count;
    }
    /**
     * The date when the user was created, i.e. when they registered on Twitch.
     */
    get creationDate() {
        return new Date(this[common_1.rawDataSymbol].created_at);
    }
    /**
     * Retrieves the channel's stream data.
     */
    async getStream() {
        return await this._client.streams.getStreamByUserId(this);
    }
    /**
     * Retrieves a list of broadcasters the user follows.
     */
    async getFollows() {
        return await this._client.users.getFollows({ user: this });
    }
    /**
     * Retrieves the follow data of the given user to the broadcaster.
     *
     * @param user The user to check the follow from.
     */
    async getFollowFrom(user) {
        return await this._client.users.getFollowFromUserToBroadcaster(user, this);
    }
    /**
     * Retrieves the follow data of the user to the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the follow to.
     */
    async getFollowTo(broadcaster) {
        return await this._client.users.getFollowFromUserToBroadcaster(this, broadcaster);
    }
    /**
     * Checks whether the user is following the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the user's follow to.
     */
    async follows(broadcaster) {
        return await this._client.users.userFollowsBroadcaster(this, broadcaster);
    }
    /**
     * Checks whether the given user is following the broadcaster.
     *
     * @param user The user to check the broadcaster's follow from.
     */
    async isFollowedBy(user) {
        return await this._client.users.userFollowsBroadcaster(user, this);
    }
    /**
     * Retrieves the subscription data for the user to the given broadcaster, or `null` if the user is not subscribed.
     *
     * @param broadcaster The broadcaster you want to get the subscription data for.
     */
    async getSubscriptionTo(broadcaster) {
        return await this._client.subscriptions.getSubscriptionForUser(broadcaster, this);
    }
    /**
     * Checks whether the user is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster you want to check the subscription for.
     */
    async isSubscribedTo(broadcaster) {
        try {
            return (await this.getSubscriptionTo(broadcaster)) !== null;
        }
        catch (e) {
            if (e instanceof NoSubscriptionProgramError_1.NoSubscriptionProgramError) {
                return false;
            }
            throw e;
        }
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], HelixUser.prototype, "_client", void 0);
HelixUser = tslib_1.__decorate([
    common_1.rtfm('api', 'HelixUser', 'id')
], HelixUser);
exports.HelixUser = HelixUser;

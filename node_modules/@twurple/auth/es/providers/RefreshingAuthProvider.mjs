import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { rtfm } from '@twurple/common';
import { accessTokenIsExpired } from "../AccessToken.mjs";
import { InvalidTokenError } from "../errors/InvalidTokenError.mjs";
import { compareScopes, loadAndCompareScopes, refreshUserToken } from "../helpers.mjs";
/**
 * An auth provider with the ability to make use of refresh tokens,
 * automatically refreshing the access token whenever necessary.
 */
let RefreshingAuthProvider = class RefreshingAuthProvider {
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * @param refreshConfig The information necessary to automatically refresh an access token.
     * @param initialToken The initial access token.
     */
    constructor(refreshConfig, initialToken) {
        /**
         * The type of tokens the provider generates.
         *
         * This auth provider generates user tokens.
         */
        this.tokenType = 'user';
        this._clientId = refreshConfig.clientId;
        this._clientSecret = refreshConfig.clientSecret;
        this._onRefresh = refreshConfig.onRefresh;
        this._accessToken = initialToken;
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, the base auth
     * provider is called.
     *
     * If the current access token is expired, automatically renew it.
     *
     * @param scopes The requested scopes.
     */
    async getAccessToken(scopes) {
        // if we don't have a current token, we just pass this and refresh right away
        if (this._accessToken.accessToken && !accessTokenIsExpired(this._accessToken)) {
            try {
                // don't create new object on every get
                if (this._accessToken.scope) {
                    compareScopes(this._accessToken.scope, scopes);
                }
                else {
                    this._accessToken = {
                        ...this._accessToken,
                        scope: await loadAndCompareScopes(this._clientId, this._accessToken.accessToken, this._accessToken.scope, scopes)
                    };
                }
                return this._accessToken;
            }
            catch (e) {
                // if loading scopes failed, ignore InvalidTokenError and proceed with refreshing
                if (!(e instanceof InvalidTokenError)) {
                    throw e;
                }
            }
        }
        const refreshedToken = await this.refresh();
        compareScopes(refreshedToken.scope, scopes);
        return refreshedToken;
    }
    /**
     * Force a refresh of the access token.
     */
    async refresh() {
        var _a;
        const tokenData = await refreshUserToken(this.clientId, this._clientSecret, this._accessToken.refreshToken);
        this._accessToken = tokenData;
        (_a = this._onRefresh) === null || _a === void 0 ? void 0 : _a.call(this, tokenData);
        return tokenData;
    }
    /**
     * The client ID.
     */
    get clientId() {
        return this._clientId;
    }
    /**
     * The scopes that are currently available using the access token.
     */
    get currentScopes() {
        var _a;
        return (_a = this._accessToken.scope) !== null && _a !== void 0 ? _a : [];
    }
};
__decorate([
    Enumerable(false)
], RefreshingAuthProvider.prototype, "_clientSecret", void 0);
__decorate([
    Enumerable(false)
], RefreshingAuthProvider.prototype, "_accessToken", void 0);
RefreshingAuthProvider = __decorate([
    rtfm('auth', 'RefreshingAuthProvider', 'clientId')
], RefreshingAuthProvider);
export { RefreshingAuthProvider };

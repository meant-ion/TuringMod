"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadAndCompareScopes = exports.compareScopes = exports.getValidTokenFromProvider = exports.getTokenInfo = exports.revokeToken = exports.refreshUserToken = exports.getAppToken = exports.exchangeCode = void 0;
const api_call_1 = require("@twurple/api-call");
const InvalidTokenError_1 = require("./errors/InvalidTokenError");
const TokenInfo_1 = require("./TokenInfo");
/** @private */
function createAccessTokenFromData(data) {
    var _a, _b;
    return {
        accessToken: data.access_token,
        refreshToken: data.refresh_token || null,
        scope: (_a = data.scope) !== null && _a !== void 0 ? _a : [],
        expiresIn: (_b = data.expires_in) !== null && _b !== void 0 ? _b : null,
        obtainmentTimestamp: Date.now()
    };
}
/**
 * Retrieves an access token with your client credentials and an authorization code.
 *
 * @param clientId The client ID of your application.
 * @param clientSecret The client secret of your application.
 * @param code The authorization code.
 * @param redirectUri The redirect URI.
 *
 * This serves no real purpose here, but must still match one of the redirect URIs you configured in the Twitch Developer dashboard.
 */
async function exchangeCode(clientId, clientSecret, code, redirectUri) {
    return createAccessTokenFromData(await api_call_1.callTwitchApi({
        type: 'auth',
        url: 'token',
        method: 'POST',
        query: {
            grant_type: 'authorization_code',
            client_id: clientId,
            client_secret: clientSecret,
            code,
            redirect_uri: redirectUri
        }
    }));
}
exports.exchangeCode = exchangeCode;
/**
 * Retrieves an app access token with your client credentials.
 *
 * @param clientId The client ID of your application.
 * @param clientSecret The client secret of your application.
 * @param clientSecret
 */
async function getAppToken(clientId, clientSecret) {
    return createAccessTokenFromData(await api_call_1.callTwitchApi({
        type: 'auth',
        url: 'token',
        method: 'POST',
        query: {
            grant_type: 'client_credentials',
            client_id: clientId,
            client_secret: clientSecret
        }
    }));
}
exports.getAppToken = getAppToken;
/**
 * Refreshes an expired access token with your client credentials and the refresh token that was given by the initial authentication.
 *
 * @param clientId The client ID of your application.
 * @param clientSecret The client secret of your application.
 * @param refreshToken The refresh token.
 */
async function refreshUserToken(clientId, clientSecret, refreshToken) {
    return createAccessTokenFromData(await api_call_1.callTwitchApi({
        type: 'auth',
        url: 'token',
        method: 'POST',
        query: {
            grant_type: 'refresh_token',
            client_id: clientId,
            client_secret: clientSecret,
            refresh_token: refreshToken
        }
    }));
}
exports.refreshUserToken = refreshUserToken;
/**
 * Revokes an access token.
 *
 * @param clientId The client ID of your application.
 * @param accessToken The access token.
 */
async function revokeToken(clientId, accessToken) {
    await api_call_1.callTwitchApi({
        type: 'auth',
        url: 'revoke',
        method: 'POST',
        query: {
            client_id: clientId,
            token: accessToken
        }
    });
}
exports.revokeToken = revokeToken;
/**
 * Retrieves information about an access token.
 *
 * @param clientId The client ID of your application.
 * @param accessToken The access token to get the information of.
 *
 * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
 */
async function getTokenInfo(accessToken, clientId) {
    try {
        const data = await api_call_1.callTwitchApi({ type: 'auth', url: 'validate' }, clientId, accessToken);
        return new TokenInfo_1.TokenInfo(data);
    }
    catch (e) {
        if (e instanceof api_call_1.HttpStatusCodeError && e.statusCode === 401) {
            throw new InvalidTokenError_1.InvalidTokenError();
        }
        throw e;
    }
}
exports.getTokenInfo = getTokenInfo;
/** @private */
async function getValidTokenFromProvider(provider, scopes, logger) {
    let lastTokenError = null;
    try {
        const accessToken = await provider.getAccessToken(scopes);
        if (accessToken) {
            // check validity
            const tokenInfo = await getTokenInfo(accessToken.accessToken);
            return { accessToken, tokenInfo };
        }
    }
    catch (e) {
        if (e instanceof InvalidTokenError_1.InvalidTokenError) {
            lastTokenError = e;
        }
        else {
            logger === null || logger === void 0 ? void 0 : logger.error(`Retrieving an access token failed: ${e.message}`);
        }
    }
    logger === null || logger === void 0 ? void 0 : logger.warn('No valid token available; trying to refresh');
    if (provider.refresh) {
        try {
            const newToken = await provider.refresh();
            if (newToken) {
                // check validity
                const tokenInfo = await getTokenInfo(newToken.accessToken);
                return { accessToken: newToken, tokenInfo };
            }
        }
        catch (e) {
            if (e instanceof InvalidTokenError_1.InvalidTokenError) {
                lastTokenError = e;
            }
            else {
                logger === null || logger === void 0 ? void 0 : logger.error(`Refreshing the access token failed: ${e.message}`);
            }
        }
    }
    throw lastTokenError !== null && lastTokenError !== void 0 ? lastTokenError : new Error('Could not retrieve a valid token');
}
exports.getValidTokenFromProvider = getValidTokenFromProvider;
/**
 * Compares scopes for a non-upgradable `AuthProvider` instance.
 *
 * @param scopesToCompare The scopes to compare against.
 * @param requestedScopes The scopes you requested.
 */
function compareScopes(scopesToCompare, requestedScopes) {
    if (requestedScopes === null || requestedScopes === void 0 ? void 0 : requestedScopes.some(scope => !scopesToCompare.includes(scope))) {
        throw new Error(`This token does not have the requested scopes (${requestedScopes.join(', ')}) and can not be upgraded.
If you need dynamically upgrading scopes, please implement the AuthProvider interface accordingly:

\thttps://twurple.js.org/reference/auth/interfaces/AuthProvider.html`);
    }
}
exports.compareScopes = compareScopes;
/**
 * Compares scopes for a non-upgradable `AuthProvider` instance, loading them from the token if necessary.
 *
 * @param clientId The client ID of your application.
 * @param token The access token.
 * @param loadedScopes The scopes that were already loaded.
 * @param requestedScopes The scopes you requested.
 */
async function loadAndCompareScopes(clientId, token, loadedScopes, requestedScopes) {
    if (requestedScopes === null || requestedScopes === void 0 ? void 0 : requestedScopes.length) {
        const scopesToCompare = loadedScopes !== null && loadedScopes !== void 0 ? loadedScopes : (await getTokenInfo(token, clientId)).scopes;
        compareScopes(scopesToCompare, requestedScopes);
        return scopesToCompare;
    }
    return loadedScopes;
}
exports.loadAndCompareScopes = loadAndCompareScopes;

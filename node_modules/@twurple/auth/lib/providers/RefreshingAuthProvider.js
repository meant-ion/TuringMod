"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefreshingAuthProvider = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const common_1 = require("@twurple/common");
const AccessToken_1 = require("../AccessToken");
const InvalidTokenError_1 = require("../errors/InvalidTokenError");
const helpers_1 = require("../helpers");
/**
 * An auth provider with the ability to make use of refresh tokens,
 * automatically refreshing the access token whenever necessary.
 */
let RefreshingAuthProvider = class RefreshingAuthProvider {
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * @param refreshConfig The information necessary to automatically refresh an access token.
     * @param initialToken The initial access token.
     */
    constructor(refreshConfig, initialToken) {
        /**
         * The type of tokens the provider generates.
         *
         * This auth provider generates user tokens.
         */
        this.tokenType = 'user';
        this._clientId = refreshConfig.clientId;
        this._clientSecret = refreshConfig.clientSecret;
        this._onRefresh = refreshConfig.onRefresh;
        this._accessToken = initialToken;
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, the base auth
     * provider is called.
     *
     * If the current access token is expired, automatically renew it.
     *
     * @param scopes The requested scopes.
     */
    async getAccessToken(scopes) {
        // if we don't have a current token, we just pass this and refresh right away
        if (this._accessToken.accessToken && !AccessToken_1.accessTokenIsExpired(this._accessToken)) {
            try {
                // don't create new object on every get
                if (this._accessToken.scope) {
                    helpers_1.compareScopes(this._accessToken.scope, scopes);
                }
                else {
                    this._accessToken = {
                        ...this._accessToken,
                        scope: await helpers_1.loadAndCompareScopes(this._clientId, this._accessToken.accessToken, this._accessToken.scope, scopes)
                    };
                }
                return this._accessToken;
            }
            catch (e) {
                // if loading scopes failed, ignore InvalidTokenError and proceed with refreshing
                if (!(e instanceof InvalidTokenError_1.InvalidTokenError)) {
                    throw e;
                }
            }
        }
        const refreshedToken = await this.refresh();
        helpers_1.compareScopes(refreshedToken.scope, scopes);
        return refreshedToken;
    }
    /**
     * Force a refresh of the access token.
     */
    async refresh() {
        var _a;
        const tokenData = await helpers_1.refreshUserToken(this.clientId, this._clientSecret, this._accessToken.refreshToken);
        this._accessToken = tokenData;
        (_a = this._onRefresh) === null || _a === void 0 ? void 0 : _a.call(this, tokenData);
        return tokenData;
    }
    /**
     * The client ID.
     */
    get clientId() {
        return this._clientId;
    }
    /**
     * The scopes that are currently available using the access token.
     */
    get currentScopes() {
        var _a;
        return (_a = this._accessToken.scope) !== null && _a !== void 0 ? _a : [];
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], RefreshingAuthProvider.prototype, "_clientSecret", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], RefreshingAuthProvider.prototype, "_accessToken", void 0);
RefreshingAuthProvider = tslib_1.__decorate([
    common_1.rtfm('auth', 'RefreshingAuthProvider', 'clientId')
], RefreshingAuthProvider);
exports.RefreshingAuthProvider = RefreshingAuthProvider;

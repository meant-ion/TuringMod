import { __decorate } from "tslib";
import { createLogger } from '@d-fischer/logger';
import getRawBody from '@d-fischer/raw-body';
import { Enumerable } from '@d-fischer/shared-utils';
import { EventEmitter } from '@d-fischer/typed-event-emitter';
import { InvalidTokenTypeError } from '@twurple/auth';
import { extractUserId } from '@twurple/common';
import { EventSubChannelBanSubscription } from "./subscriptions/EventSubChannelBanSubscription.mjs";
import { EventSubChannelCheerSubscription } from "./subscriptions/EventSubChannelCheerSubscription.mjs";
import { EventSubChannelFollowSubscription } from "./subscriptions/EventSubChannelFollowSubscription.mjs";
import { EventSubChannelHypeTrainBeginSubscription } from "./subscriptions/EventSubChannelHypeTrainBeginSubscription.mjs";
import { EventSubChannelHypeTrainEndSubscription } from "./subscriptions/EventSubChannelHypeTrainEndSubscription.mjs";
import { EventSubChannelHypeTrainProgressSubscription } from "./subscriptions/EventSubChannelHypeTrainProgressSubscription.mjs";
import { EventSubChannelModeratorAddSubscription } from "./subscriptions/EventSubChannelModeratorAddSubscription.mjs";
import { EventSubChannelModeratorRemoveSubscription } from "./subscriptions/EventSubChannelModeratorRemoveSubscription.mjs";
import { EventSubChannelPollBeginSubscription } from "./subscriptions/EventSubChannelPollBeginSubscription.mjs";
import { EventSubChannelPollEndSubscription } from "./subscriptions/EventSubChannelPollEndSubscription.mjs";
import { EventSubChannelPollProgressSubscription } from "./subscriptions/EventSubChannelPollProgressSubscription.mjs";
import { EventSubChannelPredictionBeginSubscription } from "./subscriptions/EventSubChannelPredictionBeginSubscription.mjs";
import { EventSubChannelPredictionEndSubscription } from "./subscriptions/EventSubChannelPredictionEndSubscription.mjs";
import { EventSubChannelPredictionLockSubscription } from "./subscriptions/EventSubChannelPredictionLockSubscription.mjs";
import { EventSubChannelPredictionProgressSubscription } from "./subscriptions/EventSubChannelPredictionProgressSubscription.mjs";
import { EventSubChannelRaidSubscription } from "./subscriptions/EventSubChannelRaidSubscription.mjs";
import { EventSubChannelRedemptionAddSubscription } from "./subscriptions/EventSubChannelRedemptionAddSubscription.mjs";
import { EventSubChannelRedemptionUpdateSubscription } from "./subscriptions/EventSubChannelRedemptionUpdateSubscription.mjs";
import { EventSubChannelRewardAddSubscription } from "./subscriptions/EventSubChannelRewardAddSubscription.mjs";
import { EventSubChannelRewardRemoveSubscription } from "./subscriptions/EventSubChannelRewardRemoveSubscription.mjs";
import { EventSubChannelRewardUpdateSubscription } from "./subscriptions/EventSubChannelRewardUpdateSubscription.mjs";
import { EventSubChannelSubscriptionEndSubscription } from "./subscriptions/EventSubChannelSubscriptionEndSubscription.mjs";
import { EventSubChannelSubscriptionGiftSubscription } from "./subscriptions/EventSubChannelSubscriptionGiftSubscription.mjs";
import { EventSubChannelSubscriptionMessageSubscription } from "./subscriptions/EventSubChannelSubscriptionMessageSubscription.mjs";
import { EventSubChannelSubscriptionSubscription } from "./subscriptions/EventSubChannelSubscriptionSubscription.mjs";
import { EventSubChannelUnbanSubscription } from "./subscriptions/EventSubChannelUnbanSubscription.mjs";
import { EventSubChannelUpdateSubscription } from "./subscriptions/EventSubChannelUpdateSubscription.mjs";
import { EventSubExtensionBitsTransactionCreateSubscription } from "./subscriptions/EventSubExtensionBitsTransactionCreateSubscription.mjs";
import { EventSubStreamOfflineSubscription } from "./subscriptions/EventSubStreamOfflineSubscription.mjs";
import { EventSubStreamOnlineSubscription } from "./subscriptions/EventSubStreamOnlineSubscription.mjs";
import { EventSubUserAuthorizationRevokeSubscription } from "./subscriptions/EventSubUserAuthorizationRevokeSubscription.mjs";
import { EventSubUserUpdateSubscription } from "./subscriptions/EventSubUserUpdateSubscription.mjs";
const numberRegex = /^\d+$/;
/**
 * @private
 * @hideProtected
 */
export class EventSubBase extends EventEmitter {
    constructor(config) {
        super();
        this._subscriptions = new Map();
        this._twitchSubscriptions = new Map();
        this._seenEventIds = new Set();
        this._readyToSubscribe = false;
        /**
         * Fires when a subscription is successfully verified or fails to verify.
         *
         * @param success Whether the verification succeeded.
         * @param subscription The subscription that was verified.
         */
        this.onVerify = this.registerEvent();
        /**
         * Fires when a subscription is revoked.
         *
         * @param subscription The subscription that was revoked.
         */
        this.onRevoke = this.registerEvent();
        if (config.apiClient._authProvider.tokenType !== 'app') {
            throw new InvalidTokenTypeError('EventSub requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        // catch the examples copied verbatim
        if (!config.secret || config.secret === 'thisShouldBeARandomlyGeneratedFixedString') {
            throw new Error('Please generate a secret and pass it to the constructor!');
        }
        this._apiClient = config.apiClient;
        this._secret = config.secret;
        this._logger = createLogger({
            name: 'twurple:eventsub',
            emoji: true,
            ...config.logger
        });
    }
    /**
     * Subscribes to events representing a stream going live.
     *
     * @param user The user for which to get notifications about their streams going live.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToStreamOnlineEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToStreamOnlineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubStreamOnlineSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events representing a stream going offline.
     *
     * @param user The user for which to get notifications about their streams going offline.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToStreamOfflineEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToStreamOfflineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubStreamOfflineSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events representing a change in channel metadata, e.g. stream title or category.
     *
     * @param user The user for which to get notifications about updates.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelUpdateEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user following a channel.
     *
     * @param user The user for which to get notifications about their followers.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelFollowEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelFollowEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelFollowSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user subscribing to a channel.
     *
     * @param user The user for which to get notifications for about their subscribers.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToChannelSubscriptionEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelSubscriptionSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user gifting a subscription to a channel to someone else.
     *
     * @param user The user for which to get notifications for about subscriptions people gift in their channel.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToChannelSubscriptionGiftEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelSubscriptionGiftEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelSubscriptionGiftSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user's subscription to a channel being announced.
     *
     * @param user The user for which to get notifications for about announced subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToChannelSubscriptionMessageEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelSubscriptionMessageEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelSubscriptionMessageSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user's subscription to a channel ending.
     *
     * @param user The user for which to get notifications for about ending subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToChannelSubscriptionEndEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelSubscriptionEndSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user cheering some bits.
     *
     * @param user The user for which to get notifications for about cheers they get.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelCheerEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelCheerEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelCheerSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user getting banned from a channel.
     *
     * @param user The user for which to get notifications for when users get banned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelBanEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelBanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelBanSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user getting unbanned from a channel.
     *
     * @param user The user for which to get notifications for when users get unbanned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelUnbanEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelUnbanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelUnbanSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user getting moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users get moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelModeratorAddEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelModeratorAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelModeratorAddSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user losing moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users lose moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelModeratorRemoveEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelModeratorRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelModeratorRemoveSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a broadcaster raiding another broadcaster.
     *
     * @param user The broadcaster for which to get outgoing raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRaidEventsFrom(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRaidEventsFrom: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'from');
    }
    /**
     * Subscribes to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param user The broadcaster for which to get incoming raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRaidEventsTo(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRaidEventsTo: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'to');
    }
    /**
     * Subscribes to events that represent a Channel Points reward being added to a channel.
     *
     * @param user The user for which to get notifications for when they add a reward to their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardAddEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRewardAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardAddSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardUpdateEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it is updated.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardUpdateEventsForReward(user, rewardId, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardRemoveEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove the reward.
     * @param rewardId The ID of the reward to get notifications for when it is removed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardRemoveEventsForReward(user, rewardId, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardRemoveEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represents a Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications for when their rewards are redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionAddEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications when their reward is redeemed.
     * @param rewardId The ID of the reward for which to get notifications when it is redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionAddEventsForReward(user, rewardId, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRedemptionAddEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionUpdateEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it gets updated.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionUpdateEventsForReward(user, rewardId, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a poll starting in a channel.
     *
     * @param user The broadcaster for which to receive poll begin events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPollBeginEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPollBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPollBeginSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a poll being voted on in a channel.
     *
     * @param user The broadcaster for which to receive poll progress events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPollProgressEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPollProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPollProgressSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a poll ending in a channel.
     *
     * @param user The broadcaster for which to receive poll end events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPollEndEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPollEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPollEndSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a prediction starting in a channel.
     *
     * @param user The broadcaster for which to receive prediction begin events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPredictionBeginEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPredictionBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPredictionBeginSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a prediction being voted on in a channel.
     *
     * @param user The broadcaster for which to receive prediction progress events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPredictionProgressEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPredictionProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPredictionProgressSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a prediction being locked in a channel.
     *
     * @param user The broadcaster for which to receive prediction lock events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPredictionLockEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPredictionLockEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPredictionLockSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a prediction ending in a channel.
     *
     * @param user The broadcaster for which to receive prediction end events.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelPredictionEndEvents(user, handler) {
        const broadcasterId = extractUserId(user);
        if (!numberRegex.test(broadcasterId)) {
            this._logger.warn('EventSubListener#subscribeToChannelPredictionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelPredictionEndSubscription, handler, this, broadcasterId);
    }
    /**
     * Subscribes to events that represent a Hype Train beginning.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainBeginEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainBeginSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent progress in a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainProgressEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainProgressSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent the end of a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainEndEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainEndSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a Bits transaction in an extension.
     *
     * @param clientId The Client ID of the extension for which to get notifications for about Bits transactions.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToExtensionBitsTransactionCreateEvents(clientId, handler) {
        return await this._genericSubscribe(EventSubExtensionBitsTransactionCreateSubscription, handler, this, clientId);
    }
    /**
     * Subscribes to events that represent a user revoking authorization from an application.
     *
     * @param clientId The Client ID for which to get notifications about authorization revocations.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToUserAuthorizationRevokeEvents(clientId, handler) {
        return await this._genericSubscribe(EventSubUserAuthorizationRevokeSubscription, handler, this, clientId);
    }
    /**
     * Subscribes to events that represent a user updating their account details.
     *
     * @param user The user for which to get notifications about account updates.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToUserUpdateEvents(user, handler) {
        const userId = extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToUserUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubUserUpdateSubscription, handler, this, userId);
    }
    /** @private */
    async _buildHookUrl(id) {
        var _a;
        const hostName = await this.getHostName();
        // trim slashes on both ends
        const pathPrefix = (_a = (await this.getPathPrefix())) === null || _a === void 0 ? void 0 : _a.replace(/^\/|\/$/, '');
        return `https://${hostName}${pathPrefix ? '/' : ''}${pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : ''}/event/${id}`;
    }
    /** @private */
    _dropSubscription(id) {
        this._subscriptions.delete(id);
    }
    /** @private */
    _dropTwitchSubscription(id) {
        this._twitchSubscriptions.delete(id);
    }
    /** @private */
    _registerTwitchSubscription(id, data) {
        this._twitchSubscriptions.set(id, data);
    }
    async _resumeExistingSubscriptions() {
        const subscriptions = await this._apiClient.eventSub.getSubscriptionsPaginated().getAll();
        const urlPrefix = await this._buildHookUrl('');
        this._twitchSubscriptions = new Map(subscriptions
            .map((sub) => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (sub._transport.method === 'webhook') {
                const url = sub._transport.callback;
                if (url.startsWith(urlPrefix)) {
                    const id = url.slice(urlPrefix.length);
                    return [id, sub];
                }
            }
            return undefined;
        })
            .filter((x) => !!x));
        await Promise.all([...this._subscriptions].map(async ([subId, sub]) => await sub.start(this._twitchSubscriptions.get(subId))));
    }
    _createHandleRequest() {
        return async (req, res, next) => {
            const { id } = req.params;
            const subscription = this._subscriptions.get(id);
            const twitchSubscription = this._twitchSubscriptions.get(id);
            const type = req.headers['twitch-eventsub-message-type'];
            if (subscription) {
                const messageId = req.headers['twitch-eventsub-message-id'];
                const timestamp = req.headers['twitch-eventsub-message-timestamp'];
                const body = await getRawBody(req, true);
                const algoAndSignature = req.headers['twitch-eventsub-message-signature'];
                if (algoAndSignature === undefined) {
                    this._logger.warn(`Dropping unsigned message for action ${type} of event: ${id}`);
                    res.writeHead(410);
                    res.end();
                }
                else {
                    const verified = subscription._verifyData(messageId, timestamp, body, algoAndSignature);
                    const data = JSON.parse(body);
                    if (verified) {
                        if (type === 'webhook_callback_verification') {
                            const verificationBody = data;
                            this.emit(this.onVerify, true, subscription);
                            subscription._verify();
                            if (twitchSubscription) {
                                twitchSubscription._status = 'enabled';
                            }
                            res.setHeader('Content-Length', verificationBody.challenge.length);
                            res.writeHead(200, undefined);
                            res.end(verificationBody.challenge);
                            this._logger.debug(`Successfully subscribed to event: ${id}`);
                        }
                        else if (type === 'notification') {
                            if (this._seenEventIds.has(messageId)) {
                                this._logger.debug(`Duplicate notification prevented for event: ${id}`);
                            }
                            else if (new Date(timestamp).getTime() < Date.now() - 10 * 60 * 1000) {
                                this._logger.debug(`Old notification prevented for event: ${id}`);
                            }
                            else {
                                this._seenEventIds.add(messageId);
                                setTimeout(() => this._seenEventIds.delete(messageId), 10 * 60 * 1000);
                                subscription._handleData(data.event);
                            }
                            res.writeHead(202);
                            res.end();
                        }
                        else if (type === 'revocation') {
                            this._dropSubscription(subscription.id);
                            this._dropTwitchSubscription(subscription.id);
                            this.emit(this.onRevoke, subscription);
                            this._logger.debug(`Subscription revoked by Twitch for event: ${id}`);
                        }
                        else {
                            this._logger.warn(`Unknown action ${type} for event: ${id}`);
                            res.writeHead(400);
                            res.end();
                        }
                    }
                    else {
                        this._logger.warn(`Could not verify action ${type} of event: ${id}`);
                        if (type === 'webhook_callback_verification') {
                            this.emit(this.onVerify, false, subscription);
                        }
                        res.writeHead(410);
                        res.end();
                    }
                }
            }
            else {
                this._logger.warn(`Action ${type} of unknown event attempted: ${id}`);
                res.writeHead(410);
                res.end();
            }
            next();
        };
    }
    _createDropLegacyRequest() {
        return async (req, res, next) => {
            const twitchSub = this._twitchSubscriptions.get(req.params.id);
            if (twitchSub) {
                await this._apiClient.eventSub.deleteSubscription(twitchSub.id);
                this._logger.debug(`Dropped legacy subscription for event: ${req.params.id}`);
                res.writeHead(410);
                res.end();
            }
            else {
                next();
            }
        };
    }
    _createHandleHealthRequest() {
        return async (req, res) => {
            res.end('@twurple/eventsub is listening here');
        };
    }
    async _genericSubscribe(clazz, handler, client, ...params) {
        const subscription = new clazz(handler, client, ...params);
        if (this._readyToSubscribe) {
            await subscription.start(this._twitchSubscriptions.get(subscription.id));
        }
        this._subscriptions.set(subscription.id, subscription);
        return subscription;
    }
}
__decorate([
    Enumerable(false)
], EventSubBase.prototype, "_subscriptions", void 0);
__decorate([
    Enumerable(false)
], EventSubBase.prototype, "_twitchSubscriptions", void 0);
__decorate([
    Enumerable(false)
], EventSubBase.prototype, "_seenEventIds", void 0);
__decorate([
    Enumerable(false)
], EventSubBase.prototype, "_apiClient", void 0);
__decorate([
    Enumerable(false)
], EventSubBase.prototype, "_secret", void 0);

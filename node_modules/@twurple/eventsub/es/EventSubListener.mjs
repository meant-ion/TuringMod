import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { rtfm } from '@twurple/common';
import { Server } from 'httpanda';
import { EventSubBase } from "./EventSubBase.mjs";
/**
 * A listener for the Twitch EventSub event distribution mechanism.
 *
 * @hideProtected
 * @inheritDoc
 */
let EventSubListener = class EventSubListener extends EventSubBase {
    /**
     * Creates a new EventSub listener.
     *
     * @param config
     *
     * @expandParams
     */
    constructor(config) {
        super(config);
        this._adapter = config.adapter;
    }
    /**
     * Starts the backing server and listens to incoming EventSub notifications.
     */
    async listen(port) {
        var _a;
        if (this._server) {
            throw new Error('Trying to listen while already listening');
        }
        const server = this._adapter.createHttpServer();
        this._server = new Server({
            server,
            onError: (e, req) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (e.code === 404) {
                    this._logger.warn(`Access to unknown URL/method attempted: ${req.method} ${req.url}`);
                }
            }
        });
        // needs to be first in chain but run last, for proper logging of status
        this._server.use((req, res, next) => {
            setImmediate(() => {
                this._logger.debug(`${req.method} ${req.path} - ${res.statusCode}`);
            });
            next();
        });
        this._server.get('/', this._createHandleHealthRequest());
        this._server.post('/:id', this._createDropLegacyRequest());
        this._server.post('/event/:id', this._createHandleRequest());
        const adapterListenerPort = await this._adapter.getListenerPort();
        if (adapterListenerPort && port) {
            this._logger.warn(`Your passed port (${port}) is being ignored because the adapter has overridden it.
Listening on port ${adapterListenerPort} instead.`);
        }
        const listenerPort = (_a = adapterListenerPort !== null && adapterListenerPort !== void 0 ? adapterListenerPort : port) !== null && _a !== void 0 ? _a : 443;
        await this._server.listen(listenerPort);
        this._readyToSubscribe = true;
        this._logger.info(`Listening on port ${listenerPort}`);
        await this._resumeExistingSubscriptions();
    }
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    async unlisten() {
        if (!this._server) {
            throw new Error('Trying to unlisten while not listening');
        }
        await Promise.all([...this._subscriptions.values()].map(async (sub) => await sub.suspend()));
        await this._server.close();
        this._server = undefined;
        this._readyToSubscribe = false;
    }
    async getHostName() {
        return await this._adapter.getHostName();
    }
    async getPathPrefix() {
        return this._adapter.pathPrefix;
    }
};
__decorate([
    Enumerable(false)
], EventSubListener.prototype, "_server", void 0);
EventSubListener = __decorate([
    rtfm('eventsub', 'EventSubListener')
], EventSubListener);
export { EventSubListener };

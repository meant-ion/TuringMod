import { __decorate } from "tslib";
import { rtfm } from '@twurple/common';
import * as crypto from 'crypto';
/**
 * @hideProtected
 */
let EventSubSubscription = class EventSubSubscription {
    /** @private */
    constructor(_handler, _client) {
        this._handler = _handler;
        this._client = _client;
        this._verified = false;
    }
    /**
     * Whether the subscription has been verified by Twitch.
     */
    get verified() {
        return this._verified;
    }
    get _secret() {
        return `${this.id}.${this._client._secret}`.slice(-100);
    }
    /** @private */
    get _twitchId() {
        var _a;
        return (_a = this._twitchSubscriptionData) === null || _a === void 0 ? void 0 : _a.id;
    }
    /** @private */
    _verify() {
        this._verified = true;
    }
    /** @private */
    _verifyData(messageId, timestamp, body, algoAndSignature) {
        const [algorithm, signature] = algoAndSignature.split('=', 2);
        const hash = crypto
            .createHmac(algorithm, this._secret)
            .update(messageId + timestamp + body)
            .digest('hex');
        return hash === signature;
    }
    /** @private */
    _handleData(body) {
        this._handler(this.transformData(body));
    }
    /**
     * Activates the subscription.
     */
    async start(resumeFrom) {
        if (resumeFrom) {
            if (resumeFrom.status === 'enabled') {
                this._twitchSubscriptionData = resumeFrom;
                this._client._logger.debug(`Successfully resumed subscription for event: ${this.id}`);
                return;
            }
            this._client._logger.info(`Cycling broken conflicting subscription for event: ${this.id}`);
            await this._unsubscribe();
        }
        this._twitchSubscriptionData = await this._subscribe();
        this._client._registerTwitchSubscription(this.id, this._twitchSubscriptionData);
    }
    /**
     * Suspends the subscription, not removing it from the listener.
     */
    async suspend() {
        if (!this._twitchSubscriptionData) {
            return;
        }
        await this._unsubscribe();
        this._twitchSubscriptionData = undefined;
    }
    /**
     * Deactivates the subscription and removes it from the listener.
     */
    async stop() {
        await this.suspend();
        this._client._dropSubscription(this.id);
    }
    async _getTransportOptions() {
        return {
            method: 'webhook',
            callback: await this._client._buildHookUrl(this.id),
            secret: this._secret
        };
    }
    async _unsubscribe() {
        if (this._twitchSubscriptionData) {
            await this._client._apiClient.eventSub.deleteSubscription(this._twitchSubscriptionData.id);
        }
        this._client._dropTwitchSubscription(this.id);
    }
};
EventSubSubscription = __decorate([
    rtfm('eventsub', 'EventSubSubscription')
], EventSubSubscription);
export { EventSubSubscription };

import { __assign, __awaiter, __extends, __generator, __read, __spread } from "tslib";
import { createServer, STATUS_CODES } from 'http';
import { parseUrl } from "./parseUrl.mjs";
import { Router } from "./Router.mjs";
import { dropComponents } from "./dropComponents.mjs";
var defaultOnError = function (e, req, res) {
    res.statusCode = e.code || e.status || 500;
    if (typeof e === 'string') {
        res.end(e);
    }
    else {
        res.end(e.message || STATUS_CODES[res.statusCode] || 'Unknown error');
    }
};
var Server = /** @class */ (function (_super) {
    __extends(Server, _super);
    function Server(_a) {
        var _b = _a === void 0 ? {} : _a, server = _b.server, onError = _b.onError;
        var _this = _super.call(this) || this;
        _this.handleRequest = function (req, res) {
            var parsedUrl = parseUrl(req);
            var foundRoutes = _this.find(req.method, parsedUrl.pathname);
            foundRoutes.push({
                callback: _this._on404,
                params: {},
                componentsToDrop: 0
            });
            var routeCount = foundRoutes.length;
            req.path = parsedUrl.pathname;
            req.query = parsedUrl.query;
            req.search = parsedUrl.search;
            var i = 0;
            var loop;
            var next = function (e) {
                if (e) {
                    _this._onError(e, req, res, next);
                }
                else {
                    loop();
                }
            };
            try {
                loop = function () {
                    if (!res.writableEnded) {
                        if (i >= routeCount) {
                            return;
                        }
                        var foundRoute = foundRoutes[i++];
                        req.path = dropComponents(parsedUrl.pathname, foundRoute.componentsToDrop);
                        req.param = req.params = __assign(__assign({}, req.params), foundRoute.params);
                        var callback = foundRoute.callback;
                        callback(req, res, next);
                    }
                };
                loop();
            }
            catch (e) {
                _this._onError(e, req, res, next);
            }
        };
        _this._httpServer = server;
        _this._onError = onError || defaultOnError;
        _this._on404 = _this._onError.bind(null, { code: 404 });
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Server.prototype.listen = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var _a;
                        if (!_this._httpServer) {
                            _this._httpServer = createServer();
                        }
                        _this._httpServer.on('request', _this.handleRequest);
                        (_a = _this._httpServer.listen).call.apply(_a, __spread([_this._httpServer], args, [function (e) {
                                if (e) {
                                    reject(e);
                                }
                                else {
                                    resolve(_this);
                                }
                            }]));
                    })];
            });
        });
    };
    Server.prototype.close = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (!_this._httpServer) {
                            reject('Server not open when trying to close');
                            return;
                        }
                        _this._httpServer.close(function (e) {
                            if (e) {
                                reject(e);
                            }
                            else {
                                resolve();
                            }
                        });
                    })];
            });
        });
    };
    Server.prototype.use = function (pathOrFn) {
        var fns = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fns[_i - 1] = arguments[_i];
        }
        var path = (typeof pathOrFn === 'string' && pathOrFn) || '/';
        var callbacks = typeof pathOrFn === 'string' ? fns : __spread([pathOrFn], fns);
        return _super.prototype.use.apply(this, __spread([path], callbacks));
    };
    return Server;
}(Router));
export { Server };
//# sourceMappingURL=Server.mjs.map
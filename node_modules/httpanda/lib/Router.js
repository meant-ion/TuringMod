"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
var tslib_1 = require("tslib");
var pathToRegex_1 = require("./pathToRegex");
var Router = /** @class */ (function () {
    function Router() {
        this.routes = [];
        this.all = this.add.bind(this, undefined);
        this.head = this.add.bind(this, 'HEAD');
        this.options = this.add.bind(this, 'OPTIONS');
        this.get = this.add.bind(this, 'GET');
        this.post = this.add.bind(this, 'POST');
        this.put = this.add.bind(this, 'PUT');
        this.patch = this.add.bind(this, 'PATCH');
        this.delete = this.add.bind(this, 'DELETE');
        this.connect = this.add.bind(this, 'CONNECT');
        this.trace = this.add.bind(this, 'TRACE');
    }
    Router.prototype.use = function (path) {
        var callbacks = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            callbacks[_i - 1] = arguments[_i];
        }
        if (callbacks.length) {
            var _a = tslib_1.__read(pathToRegex_1.pathToRegex(path, false), 3), regex = _a[0], paramNames = _a[1], componentsToDrop = _a[2];
            this.routes.push({ regex: regex, paramNames: paramNames, callbacks: callbacks, componentsToDrop: componentsToDrop });
        }
        return this;
    };
    Router.prototype.add = function (method, path) {
        var callbacks = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            callbacks[_i - 2] = arguments[_i];
        }
        if (callbacks.length) {
            var _a = tslib_1.__read(pathToRegex_1.pathToRegex(path), 2), regex = _a[0], paramNames = _a[1];
            this.routes.push({ regex: regex, method: method, paramNames: paramNames, callbacks: callbacks, componentsToDrop: 0 });
        }
        return this;
    };
    Router.prototype.find = function (requestMethod, requestPath) {
        var e_1, _a;
        // we need this because GET handlers also need to respond to HEAD - and we don't want to check it on every iteration
        var isHead = requestMethod === 'HEAD';
        var foundCallbacks = [];
        var _loop_1 = function (regex, method, paramNames, callbacks, componentsToDrop) {
            var e_2, _a;
            if (!method || method === requestMethod || (isHead && method === 'GET')) {
                if (paramNames.length) {
                    var matches = regex.exec(requestPath);
                    if (matches) {
                        var params_1 = {};
                        var i = 1;
                        try {
                            for (var paramNames_1 = (e_2 = void 0, tslib_1.__values(paramNames)), paramNames_1_1 = paramNames_1.next(); !paramNames_1_1.done; paramNames_1_1 = paramNames_1.next()) {
                                var paramName = paramNames_1_1.value;
                                params_1[paramName] = matches[i++];
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (paramNames_1_1 && !paramNames_1_1.done && (_a = paramNames_1.return)) _a.call(paramNames_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        foundCallbacks.push.apply(foundCallbacks, tslib_1.__spread(callbacks.map(function (callback) { return ({ params: params_1, callback: callback, componentsToDrop: componentsToDrop }); })));
                    }
                }
                else if (regex.test(requestPath)) {
                    foundCallbacks.push.apply(foundCallbacks, tslib_1.__spread(callbacks.map(function (callback) { return ({ params: {}, callback: callback, componentsToDrop: componentsToDrop }); })));
                }
            }
        };
        try {
            for (var _b = tslib_1.__values(this.routes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = _c.value, regex = _d.regex, method = _d.method, paramNames = _d.paramNames, callbacks = _d.callbacks, componentsToDrop = _d.componentsToDrop;
                _loop_1(regex, method, paramNames, callbacks, componentsToDrop);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return foundCallbacks;
    };
    return Router;
}());
exports.Router = Router;
//# sourceMappingURL=Router.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
var tslib_1 = require("tslib");
var http_1 = require("http");
var parseUrl_1 = require("./parseUrl");
var Router_1 = require("./Router");
var dropComponents_1 = require("./dropComponents");
var defaultOnError = function (e, req, res) {
    res.statusCode = e.code || e.status || 500;
    if (typeof e === 'string') {
        res.end(e);
    }
    else {
        res.end(e.message || http_1.STATUS_CODES[res.statusCode] || 'Unknown error');
    }
};
var Server = /** @class */ (function (_super) {
    tslib_1.__extends(Server, _super);
    function Server(_a) {
        var _b = _a === void 0 ? {} : _a, server = _b.server, onError = _b.onError;
        var _this = _super.call(this) || this;
        _this.handleRequest = function (req, res) {
            var parsedUrl = parseUrl_1.parseUrl(req);
            var foundRoutes = _this.find(req.method, parsedUrl.pathname);
            foundRoutes.push({
                callback: _this._on404,
                params: {},
                componentsToDrop: 0
            });
            var routeCount = foundRoutes.length;
            req.path = parsedUrl.pathname;
            req.query = parsedUrl.query;
            req.search = parsedUrl.search;
            var i = 0;
            var loop;
            var next = function (e) {
                if (e) {
                    _this._onError(e, req, res, next);
                }
                else {
                    loop();
                }
            };
            try {
                loop = function () {
                    if (!res.writableEnded) {
                        if (i >= routeCount) {
                            return;
                        }
                        var foundRoute = foundRoutes[i++];
                        req.path = dropComponents_1.dropComponents(parsedUrl.pathname, foundRoute.componentsToDrop);
                        req.param = req.params = tslib_1.__assign(tslib_1.__assign({}, req.params), foundRoute.params);
                        var callback = foundRoute.callback;
                        callback(req, res, next);
                    }
                };
                loop();
            }
            catch (e) {
                _this._onError(e, req, res, next);
            }
        };
        _this._httpServer = server;
        _this._onError = onError || defaultOnError;
        _this._on404 = _this._onError.bind(null, { code: 404 });
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Server.prototype.listen = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var _a;
                        if (!_this._httpServer) {
                            _this._httpServer = http_1.createServer();
                        }
                        _this._httpServer.on('request', _this.handleRequest);
                        (_a = _this._httpServer.listen).call.apply(_a, tslib_1.__spread([_this._httpServer], args, [function (e) {
                                if (e) {
                                    reject(e);
                                }
                                else {
                                    resolve(_this);
                                }
                            }]));
                    })];
            });
        });
    };
    Server.prototype.close = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (!_this._httpServer) {
                            reject('Server not open when trying to close');
                            return;
                        }
                        _this._httpServer.close(function (e) {
                            if (e) {
                                reject(e);
                            }
                            else {
                                resolve();
                            }
                        });
                    })];
            });
        });
    };
    Server.prototype.use = function (pathOrFn) {
        var fns = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fns[_i - 1] = arguments[_i];
        }
        var path = (typeof pathOrFn === 'string' && pathOrFn) || '/';
        var callbacks = typeof pathOrFn === 'string' ? fns : tslib_1.__spread([pathOrFn], fns);
        return _super.prototype.use.apply(this, tslib_1.__spread([path], callbacks));
    };
    return Server;
}(Router_1.Router));
exports.Server = Server;
//# sourceMappingURL=Server.js.map